// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GRID_FOXGLOVE_H_
#define FLATBUFFERS_GENERATED_GRID_FOXGLOVE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 9,
             "Non-compatible flatbuffers version included");

namespace foxglove {

struct PackedElementField;
struct PackedElementFieldBuilder;

struct Quaternion;
struct QuaternionBuilder;

struct Vector3;
struct Vector3Builder;

struct Pose;
struct PoseBuilder;

struct Time;

struct Vector2;
struct Vector2Builder;

struct Grid;
struct GridBuilder;

inline const ::flatbuffers::TypeTable *PackedElementFieldTypeTable();

inline const ::flatbuffers::TypeTable *QuaternionTypeTable();

inline const ::flatbuffers::TypeTable *Vector3TypeTable();

inline const ::flatbuffers::TypeTable *PoseTypeTable();

inline const ::flatbuffers::TypeTable *TimeTypeTable();

inline const ::flatbuffers::TypeTable *Vector2TypeTable();

inline const ::flatbuffers::TypeTable *GridTypeTable();

/// Numeric type
enum NumericType : uint8_t {
  NumericType_UNKNOWN = 0,
  NumericType_UINT8 = 1,
  NumericType_INT8 = 2,
  NumericType_UINT16 = 3,
  NumericType_INT16 = 4,
  NumericType_UINT32 = 5,
  NumericType_INT32 = 6,
  NumericType_FLOAT32 = 7,
  NumericType_FLOAT64 = 8,
  NumericType_MIN = NumericType_UNKNOWN,
  NumericType_MAX = NumericType_FLOAT64
};

inline const NumericType (&EnumValuesNumericType())[9] {
  static const NumericType values[] = {
    NumericType_UNKNOWN,
    NumericType_UINT8,
    NumericType_INT8,
    NumericType_UINT16,
    NumericType_INT16,
    NumericType_UINT32,
    NumericType_INT32,
    NumericType_FLOAT32,
    NumericType_FLOAT64
  };
  return values;
}

inline const char * const *EnumNamesNumericType() {
  static const char * const names[10] = {
    "UNKNOWN",
    "UINT8",
    "INT8",
    "UINT16",
    "INT16",
    "UINT32",
    "INT32",
    "FLOAT32",
    "FLOAT64",
    nullptr
  };
  return names;
}

inline const char *EnumNameNumericType(NumericType e) {
  if (::flatbuffers::IsOutRange(e, NumericType_UNKNOWN, NumericType_FLOAT64)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNumericType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Time FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t sec_;
  uint32_t nsec_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TimeTypeTable();
  }
  Time()
      : sec_(0),
        nsec_(0) {
  }
  Time(uint32_t _sec, uint32_t _nsec)
      : sec_(::flatbuffers::EndianScalar(_sec)),
        nsec_(::flatbuffers::EndianScalar(_nsec)) {
  }
  /// Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z
  uint32_t sec() const {
    return ::flatbuffers::EndianScalar(sec_);
  }
  /// Nano-second fractions from 0 to 999,999,999 inclusive
  uint32_t nsec() const {
    return ::flatbuffers::EndianScalar(nsec_);
  }
};
FLATBUFFERS_STRUCT_END(Time, 8);

/// A field present within each element in a byte array of packed elements.
struct PackedElementField FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PackedElementFieldBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PackedElementFieldTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_OFFSET = 6,
    VT_TYPE = 8
  };
  /// Name of the field
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Byte offset from start of data buffer
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  /// Type of data in the field. Integers are stored using little-endian byte order.
  foxglove::NumericType type() const {
    return static_cast<foxglove::NumericType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct PackedElementFieldBuilder {
  typedef PackedElementField Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(PackedElementField::VT_NAME, name);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(PackedElementField::VT_OFFSET, offset, 0);
  }
  void add_type(foxglove::NumericType type) {
    fbb_.AddElement<uint8_t>(PackedElementField::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  explicit PackedElementFieldBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PackedElementField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PackedElementField>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PackedElementField> CreatePackedElementField(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint32_t offset = 0,
    foxglove::NumericType type = foxglove::NumericType_UNKNOWN) {
  PackedElementFieldBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PackedElementField> CreatePackedElementFieldDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t offset = 0,
    foxglove::NumericType type = foxglove::NumericType_UNKNOWN) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return foxglove::CreatePackedElementField(
      _fbb,
      name__,
      offset,
      type);
}

/// A [quaternion](https://eater.net/quaternions) representing a rotation in 3D space
struct Quaternion FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QuaternionBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QuaternionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8,
    VT_W = 10
  };
  /// x value
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  /// y value
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  /// z value
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  /// w value
  double w() const {
    return GetField<double>(VT_W, 1.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_Z, 8) &&
           VerifyField<double>(verifier, VT_W, 8) &&
           verifier.EndTable();
  }
};

struct QuaternionBuilder {
  typedef Quaternion Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(Quaternion::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Quaternion::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Quaternion::VT_Z, z, 0.0);
  }
  void add_w(double w) {
    fbb_.AddElement<double>(Quaternion::VT_W, w, 1.0);
  }
  explicit QuaternionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Quaternion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Quaternion>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Quaternion> CreateQuaternion(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0,
    double w = 1.0) {
  QuaternionBuilder builder_(_fbb);
  builder_.add_w(w);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

/// A vector in 3D space that represents a direction only
struct Vector3 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Vector3Builder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vector3TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  /// x coordinate length
  double x() const {
    return GetField<double>(VT_X, 1.0);
  }
  /// y coordinate length
  double y() const {
    return GetField<double>(VT_Y, 1.0);
  }
  /// z coordinate length
  double z() const {
    return GetField<double>(VT_Z, 1.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_Z, 8) &&
           verifier.EndTable();
  }
};

struct Vector3Builder {
  typedef Vector3 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(Vector3::VT_X, x, 1.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Vector3::VT_Y, y, 1.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Vector3::VT_Z, z, 1.0);
  }
  explicit Vector3Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Vector3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Vector3>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Vector3> CreateVector3(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double x = 1.0,
    double y = 1.0,
    double z = 1.0) {
  Vector3Builder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

/// A position and orientation for an object or reference frame in 3D space
struct Pose FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PoseBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PoseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_ORIENTATION = 6
  };
  /// Point denoting position in 3D space
  const foxglove::Vector3 *position() const {
    return GetPointer<const foxglove::Vector3 *>(VT_POSITION);
  }
  /// Quaternion denoting orientation in 3D space
  const foxglove::Quaternion *orientation() const {
    return GetPointer<const foxglove::Quaternion *>(VT_ORIENTATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyOffset(verifier, VT_ORIENTATION) &&
           verifier.VerifyTable(orientation()) &&
           verifier.EndTable();
  }
};

struct PoseBuilder {
  typedef Pose Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_position(::flatbuffers::Offset<foxglove::Vector3> position) {
    fbb_.AddOffset(Pose::VT_POSITION, position);
  }
  void add_orientation(::flatbuffers::Offset<foxglove::Quaternion> orientation) {
    fbb_.AddOffset(Pose::VT_ORIENTATION, orientation);
  }
  explicit PoseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pose>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Pose> CreatePose(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<foxglove::Vector3> position = 0,
    ::flatbuffers::Offset<foxglove::Quaternion> orientation = 0) {
  PoseBuilder builder_(_fbb);
  builder_.add_orientation(orientation);
  builder_.add_position(position);
  return builder_.Finish();
}

/// A vector in 2D space that represents a direction only
struct Vector2 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Vector2Builder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vector2TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6
  };
  /// x coordinate length
  double x() const {
    return GetField<double>(VT_X, 1.0);
  }
  /// y coordinate length
  double y() const {
    return GetField<double>(VT_Y, 1.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           verifier.EndTable();
  }
};

struct Vector2Builder {
  typedef Vector2 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(Vector2::VT_X, x, 1.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Vector2::VT_Y, y, 1.0);
  }
  explicit Vector2Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Vector2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Vector2>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Vector2> CreateVector2(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double x = 1.0,
    double y = 1.0) {
  Vector2Builder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

/// A 2D grid of data
struct Grid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GridBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GridTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_FRAME_ID = 6,
    VT_POSE = 8,
    VT_COLUMN_COUNT = 10,
    VT_CELL_SIZE = 12,
    VT_ROW_STRIDE = 14,
    VT_CELL_STRIDE = 16,
    VT_FIELDS = 18,
    VT_DATA = 20
  };
  /// Timestamp of grid
  const foxglove::Time *timestamp() const {
    return GetStruct<const foxglove::Time *>(VT_TIMESTAMP);
  }
  /// Frame of reference
  const ::flatbuffers::String *frame_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FRAME_ID);
  }
  /// Origin of grid's corner relative to frame of reference; grid is positioned in the x-y plane relative to this origin
  const foxglove::Pose *pose() const {
    return GetPointer<const foxglove::Pose *>(VT_POSE);
  }
  /// Number of grid columns
  uint32_t column_count() const {
    return GetField<uint32_t>(VT_COLUMN_COUNT, 0);
  }
  /// Size of single grid cell along x and y axes, relative to `pose`
  const foxglove::Vector2 *cell_size() const {
    return GetPointer<const foxglove::Vector2 *>(VT_CELL_SIZE);
  }
  /// Number of bytes between rows in `data`
  uint32_t row_stride() const {
    return GetField<uint32_t>(VT_ROW_STRIDE, 0);
  }
  /// Number of bytes between cells within a row in `data`
  uint32_t cell_stride() const {
    return GetField<uint32_t>(VT_CELL_STRIDE, 0);
  }
  /// Fields in `data`. `red`, `green`, `blue`, and `alpha` are optional for customizing the grid's color.
  const ::flatbuffers::Vector<::flatbuffers::Offset<foxglove::PackedElementField>> *fields() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<foxglove::PackedElementField>> *>(VT_FIELDS);
  }
  /// Grid cell data, interpreted using `fields`, in row-major (y-major) order
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<foxglove::Time>(verifier, VT_TIMESTAMP, 4) &&
           VerifyOffset(verifier, VT_FRAME_ID) &&
           verifier.VerifyString(frame_id()) &&
           VerifyOffset(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyField<uint32_t>(verifier, VT_COLUMN_COUNT, 4) &&
           VerifyOffset(verifier, VT_CELL_SIZE) &&
           verifier.VerifyTable(cell_size()) &&
           VerifyField<uint32_t>(verifier, VT_ROW_STRIDE, 4) &&
           VerifyField<uint32_t>(verifier, VT_CELL_STRIDE, 4) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct GridBuilder {
  typedef Grid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp(const foxglove::Time *timestamp) {
    fbb_.AddStruct(Grid::VT_TIMESTAMP, timestamp);
  }
  void add_frame_id(::flatbuffers::Offset<::flatbuffers::String> frame_id) {
    fbb_.AddOffset(Grid::VT_FRAME_ID, frame_id);
  }
  void add_pose(::flatbuffers::Offset<foxglove::Pose> pose) {
    fbb_.AddOffset(Grid::VT_POSE, pose);
  }
  void add_column_count(uint32_t column_count) {
    fbb_.AddElement<uint32_t>(Grid::VT_COLUMN_COUNT, column_count, 0);
  }
  void add_cell_size(::flatbuffers::Offset<foxglove::Vector2> cell_size) {
    fbb_.AddOffset(Grid::VT_CELL_SIZE, cell_size);
  }
  void add_row_stride(uint32_t row_stride) {
    fbb_.AddElement<uint32_t>(Grid::VT_ROW_STRIDE, row_stride, 0);
  }
  void add_cell_stride(uint32_t cell_stride) {
    fbb_.AddElement<uint32_t>(Grid::VT_CELL_STRIDE, cell_stride, 0);
  }
  void add_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<foxglove::PackedElementField>>> fields) {
    fbb_.AddOffset(Grid::VT_FIELDS, fields);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Grid::VT_DATA, data);
  }
  explicit GridBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Grid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Grid>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Grid> CreateGrid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const foxglove::Time *timestamp = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> frame_id = 0,
    ::flatbuffers::Offset<foxglove::Pose> pose = 0,
    uint32_t column_count = 0,
    ::flatbuffers::Offset<foxglove::Vector2> cell_size = 0,
    uint32_t row_stride = 0,
    uint32_t cell_stride = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<foxglove::PackedElementField>>> fields = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  GridBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_fields(fields);
  builder_.add_cell_stride(cell_stride);
  builder_.add_row_stride(row_stride);
  builder_.add_cell_size(cell_size);
  builder_.add_column_count(column_count);
  builder_.add_pose(pose);
  builder_.add_frame_id(frame_id);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Grid> CreateGridDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const foxglove::Time *timestamp = nullptr,
    const char *frame_id = nullptr,
    ::flatbuffers::Offset<foxglove::Pose> pose = 0,
    uint32_t column_count = 0,
    ::flatbuffers::Offset<foxglove::Vector2> cell_size = 0,
    uint32_t row_stride = 0,
    uint32_t cell_stride = 0,
    const std::vector<::flatbuffers::Offset<foxglove::PackedElementField>> *fields = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto frame_id__ = frame_id ? _fbb.CreateString(frame_id) : 0;
  auto fields__ = fields ? _fbb.CreateVector<::flatbuffers::Offset<foxglove::PackedElementField>>(*fields) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return foxglove::CreateGrid(
      _fbb,
      timestamp,
      frame_id__,
      pose,
      column_count,
      cell_size,
      row_stride,
      cell_stride,
      fields__,
      data__);
}

inline const ::flatbuffers::TypeTable *NumericTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    foxglove::NumericTypeTypeTable
  };
  static const char * const names[] = {
    "UNKNOWN",
    "UINT8",
    "INT8",
    "UINT16",
    "INT16",
    "UINT32",
    "INT32",
    "FLOAT32",
    "FLOAT64"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 9, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *PackedElementFieldTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    foxglove::NumericTypeTypeTable
  };
  static const char * const names[] = {
    "name",
    "offset",
    "type"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *QuaternionTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const char * const names[] = {
    "x",
    "y",
    "z",
    "w"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *Vector3TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const char * const names[] = {
    "x",
    "y",
    "z"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *PoseTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    foxglove::Vector3TypeTable,
    foxglove::QuaternionTypeTable
  };
  static const char * const names[] = {
    "position",
    "orientation"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TimeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8 };
  static const char * const names[] = {
    "sec",
    "nsec"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 2, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *Vector2TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_DOUBLE, 0, -1 },
    { ::flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const char * const names[] = {
    "x",
    "y"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *GridTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 3 },
    { ::flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    foxglove::TimeTypeTable,
    foxglove::PoseTypeTable,
    foxglove::Vector2TypeTable,
    foxglove::PackedElementFieldTypeTable
  };
  static const char * const names[] = {
    "timestamp",
    "frame_id",
    "pose",
    "column_count",
    "cell_size",
    "row_stride",
    "cell_stride",
    "fields",
    "data"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const foxglove::Grid *GetGrid(const void *buf) {
  return ::flatbuffers::GetRoot<foxglove::Grid>(buf);
}

inline const foxglove::Grid *GetSizePrefixedGrid(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<foxglove::Grid>(buf);
}

inline bool VerifyGridBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<foxglove::Grid>(nullptr);
}

inline bool VerifySizePrefixedGridBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<foxglove::Grid>(nullptr);
}

inline void FinishGridBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<foxglove::Grid> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGridBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<foxglove::Grid> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace foxglove

#endif  // FLATBUFFERS_GENERATED_GRID_FOXGLOVE_H_
