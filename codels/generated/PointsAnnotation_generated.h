// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_POINTSANNOTATION_FOXGLOVE_H_
#define FLATBUFFERS_GENERATED_POINTSANNOTATION_FOXGLOVE_H_

#include "flatbuffers/flatbuffers.h"

#include "Color_generated.h"
#include "Point2_generated.h"
#include "Time_generated.h"

namespace foxglove {

struct PointsAnnotation;

/// Type of points annotation
enum PointsAnnotationType {
  PointsAnnotationType_UNKNOWN = 0  /// Individual points: 0, 1, 2, ...
,
  PointsAnnotationType_POINTS = 1  /// Closed polygon: 0-1, 1-2, ..., (n-1)-n, n-0
,
  PointsAnnotationType_LINE_LOOP = 2  /// Connected line segments: 0-1, 1-2, ..., (n-1)-n
,
  PointsAnnotationType_LINE_STRIP = 3  /// Individual line segments: 0-1, 2-3, 4-5, ...
,
  PointsAnnotationType_LINE_LIST = 4,
  PointsAnnotationType_MIN = PointsAnnotationType_UNKNOWN,
  PointsAnnotationType_MAX = PointsAnnotationType_LINE_LIST
};

inline const PointsAnnotationType (&EnumValuesPointsAnnotationType())[5] {
  static const PointsAnnotationType values[] = {
    PointsAnnotationType_UNKNOWN,
    PointsAnnotationType_POINTS,
    PointsAnnotationType_LINE_LOOP,
    PointsAnnotationType_LINE_STRIP,
    PointsAnnotationType_LINE_LIST
  };
  return values;
}

inline const char * const *EnumNamesPointsAnnotationType() {
  static const char * const names[] = {
    "UNKNOWN",
    "POINTS",
    "LINE_LOOP",
    "LINE_STRIP",
    "LINE_LIST",
    nullptr
  };
  return names;
}

inline const char *EnumNamePointsAnnotationType(PointsAnnotationType e) {
  if (e < PointsAnnotationType_UNKNOWN || e > PointsAnnotationType_LINE_LIST) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPointsAnnotationType()[index];
}

/// An array of points on a 2D image
struct PointsAnnotation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_TYPE = 6,
    VT_POINTS = 8,
    VT_OUTLINE_COLOR = 10,
    VT_OUTLINE_COLORS = 12,
    VT_FILL_COLOR = 14,
    VT_THICKNESS = 16
  };
  /// Timestamp of annotation
  const Time *timestamp() const {
    return GetStruct<const Time *>(VT_TIMESTAMP);
  }
  /// Type of points annotation to draw
  PointsAnnotationType type() const {
    return static_cast<PointsAnnotationType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  /// Points in 2D image coordinates (pixels)
  const flatbuffers::Vector<flatbuffers::Offset<Point2>> *points() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Point2>> *>(VT_POINTS);
  }
  /// Outline color
  const Color *outline_color() const {
    return GetPointer<const Color *>(VT_OUTLINE_COLOR);
  }
  /// Per-point colors, if `type` is `POINTS`, or per-segment stroke colors, if `type` is `LINE_LIST`.
  const flatbuffers::Vector<flatbuffers::Offset<Color>> *outline_colors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Color>> *>(VT_OUTLINE_COLORS);
  }
  /// Fill color
  const Color *fill_color() const {
    return GetPointer<const Color *>(VT_FILL_COLOR);
  }
  /// Stroke thickness in pixels
  double thickness() const {
    return GetField<double>(VT_THICKNESS, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Time>(verifier, VT_TIMESTAMP) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           VerifyOffset(verifier, VT_OUTLINE_COLOR) &&
           verifier.VerifyTable(outline_color()) &&
           VerifyOffset(verifier, VT_OUTLINE_COLORS) &&
           verifier.VerifyVector(outline_colors()) &&
           verifier.VerifyVectorOfTables(outline_colors()) &&
           VerifyOffset(verifier, VT_FILL_COLOR) &&
           verifier.VerifyTable(fill_color()) &&
           VerifyField<double>(verifier, VT_THICKNESS) &&
           verifier.EndTable();
  }
};

struct PointsAnnotationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(const Time *timestamp) {
    fbb_.AddStruct(PointsAnnotation::VT_TIMESTAMP, timestamp);
  }
  void add_type(PointsAnnotationType type) {
    fbb_.AddElement<uint8_t>(PointsAnnotation::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_points(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Point2>>> points) {
    fbb_.AddOffset(PointsAnnotation::VT_POINTS, points);
  }
  void add_outline_color(flatbuffers::Offset<Color> outline_color) {
    fbb_.AddOffset(PointsAnnotation::VT_OUTLINE_COLOR, outline_color);
  }
  void add_outline_colors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Color>>> outline_colors) {
    fbb_.AddOffset(PointsAnnotation::VT_OUTLINE_COLORS, outline_colors);
  }
  void add_fill_color(flatbuffers::Offset<Color> fill_color) {
    fbb_.AddOffset(PointsAnnotation::VT_FILL_COLOR, fill_color);
  }
  void add_thickness(double thickness) {
    fbb_.AddElement<double>(PointsAnnotation::VT_THICKNESS, thickness, 0.0);
  }
  explicit PointsAnnotationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PointsAnnotationBuilder &operator=(const PointsAnnotationBuilder &);
  flatbuffers::Offset<PointsAnnotation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PointsAnnotation>(end);
    return o;
  }
};

inline flatbuffers::Offset<PointsAnnotation> CreatePointsAnnotation(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Time *timestamp = 0,
    PointsAnnotationType type = PointsAnnotationType_UNKNOWN,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Point2>>> points = 0,
    flatbuffers::Offset<Color> outline_color = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Color>>> outline_colors = 0,
    flatbuffers::Offset<Color> fill_color = 0,
    double thickness = 0.0) {
  PointsAnnotationBuilder builder_(_fbb);
  builder_.add_thickness(thickness);
  builder_.add_fill_color(fill_color);
  builder_.add_outline_colors(outline_colors);
  builder_.add_outline_color(outline_color);
  builder_.add_points(points);
  builder_.add_timestamp(timestamp);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<PointsAnnotation> CreatePointsAnnotationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Time *timestamp = 0,
    PointsAnnotationType type = PointsAnnotationType_UNKNOWN,
    const std::vector<flatbuffers::Offset<Point2>> *points = nullptr,
    flatbuffers::Offset<Color> outline_color = 0,
    const std::vector<flatbuffers::Offset<Color>> *outline_colors = nullptr,
    flatbuffers::Offset<Color> fill_color = 0,
    double thickness = 0.0) {
  auto points__ = points ? _fbb.CreateVector<flatbuffers::Offset<Point2>>(*points) : 0;
  auto outline_colors__ = outline_colors ? _fbb.CreateVector<flatbuffers::Offset<Color>>(*outline_colors) : 0;
  return foxglove::CreatePointsAnnotation(
      _fbb,
      timestamp,
      type,
      points__,
      outline_color,
      outline_colors__,
      fill_color,
      thickness);
}

inline const foxglove::PointsAnnotation *GetPointsAnnotation(const void *buf) {
  return flatbuffers::GetRoot<foxglove::PointsAnnotation>(buf);
}

inline const foxglove::PointsAnnotation *GetSizePrefixedPointsAnnotation(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<foxglove::PointsAnnotation>(buf);
}

inline bool VerifyPointsAnnotationBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<foxglove::PointsAnnotation>(nullptr);
}

inline bool VerifySizePrefixedPointsAnnotationBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<foxglove::PointsAnnotation>(nullptr);
}

inline void FinishPointsAnnotationBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<foxglove::PointsAnnotation> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPointsAnnotationBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<foxglove::PointsAnnotation> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace foxglove

#endif  // FLATBUFFERS_GENERATED_POINTSANNOTATION_FOXGLOVE_H_
