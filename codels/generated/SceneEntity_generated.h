// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCENEENTITY_FOXGLOVE_H_
#define FLATBUFFERS_GENERATED_SCENEENTITY_FOXGLOVE_H_

#include "flatbuffers/flatbuffers.h"

#include "ArrowPrimitive_generated.h"
#include "Color_generated.h"
#include "CubePrimitive_generated.h"
#include "CylinderPrimitive_generated.h"
#include "Duration_generated.h"
#include "KeyValuePair_generated.h"
#include "LinePrimitive_generated.h"
#include "ModelPrimitive_generated.h"
#include "Point3_generated.h"
#include "Pose_generated.h"
#include "Quaternion_generated.h"
#include "SpherePrimitive_generated.h"
#include "TextPrimitive_generated.h"
#include "Time_generated.h"
#include "TriangleListPrimitive_generated.h"
#include "Vector3_generated.h"

namespace foxglove {

struct SceneEntity;

/// A visual element in a 3D scene. An entity may be composed of multiple primitives which all share the same frame of reference.
struct SceneEntity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_FRAME_ID = 6,
    VT_ID = 8,
    VT_LIFETIME = 10,
    VT_FRAME_LOCKED = 12,
    VT_METADATA = 14,
    VT_ARROWS = 16,
    VT_CUBES = 18,
    VT_SPHERES = 20,
    VT_CYLINDERS = 22,
    VT_LINES = 24,
    VT_TRIANGLES = 26,
    VT_TEXTS = 28,
    VT_MODELS = 30
  };
  /// Timestamp of the entity
  const Time *timestamp() const {
    return GetStruct<const Time *>(VT_TIMESTAMP);
  }
  /// Frame of reference
  const flatbuffers::String *frame_id() const {
    return GetPointer<const flatbuffers::String *>(VT_FRAME_ID);
  }
  /// Identifier for the entity. A entity will replace any prior entity on the same topic with the same `id`.
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  /// Length of time (relative to `timestamp`) after which the entity should be automatically removed. Zero value indicates the entity should remain visible until it is replaced or deleted.
  const Duration *lifetime() const {
    return GetStruct<const Duration *>(VT_LIFETIME);
  }
  /// Whether the entity should keep its location in the fixed frame (false) or follow the frame specified in `frame_id` as it moves relative to the fixed frame (true)
  bool frame_locked() const {
    return GetField<uint8_t>(VT_FRAME_LOCKED, 0) != 0;
  }
  /// Additional user-provided metadata associated with the entity. Keys must be unique.
  const flatbuffers::Vector<flatbuffers::Offset<KeyValuePair>> *metadata() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KeyValuePair>> *>(VT_METADATA);
  }
  /// Arrow primitives
  const flatbuffers::Vector<flatbuffers::Offset<ArrowPrimitive>> *arrows() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ArrowPrimitive>> *>(VT_ARROWS);
  }
  /// Cube primitives
  const flatbuffers::Vector<flatbuffers::Offset<CubePrimitive>> *cubes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CubePrimitive>> *>(VT_CUBES);
  }
  /// Sphere primitives
  const flatbuffers::Vector<flatbuffers::Offset<SpherePrimitive>> *spheres() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SpherePrimitive>> *>(VT_SPHERES);
  }
  /// Cylinder primitives
  const flatbuffers::Vector<flatbuffers::Offset<CylinderPrimitive>> *cylinders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CylinderPrimitive>> *>(VT_CYLINDERS);
  }
  /// Line primitives
  const flatbuffers::Vector<flatbuffers::Offset<LinePrimitive>> *lines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LinePrimitive>> *>(VT_LINES);
  }
  /// Triangle list primitives
  const flatbuffers::Vector<flatbuffers::Offset<TriangleListPrimitive>> *triangles() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TriangleListPrimitive>> *>(VT_TRIANGLES);
  }
  /// Text primitives
  const flatbuffers::Vector<flatbuffers::Offset<TextPrimitive>> *texts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TextPrimitive>> *>(VT_TEXTS);
  }
  /// Model primitives
  const flatbuffers::Vector<flatbuffers::Offset<ModelPrimitive>> *models() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ModelPrimitive>> *>(VT_MODELS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Time>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_FRAME_ID) &&
           verifier.VerifyString(frame_id()) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<Duration>(verifier, VT_LIFETIME) &&
           VerifyField<uint8_t>(verifier, VT_FRAME_LOCKED) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyVector(metadata()) &&
           verifier.VerifyVectorOfTables(metadata()) &&
           VerifyOffset(verifier, VT_ARROWS) &&
           verifier.VerifyVector(arrows()) &&
           verifier.VerifyVectorOfTables(arrows()) &&
           VerifyOffset(verifier, VT_CUBES) &&
           verifier.VerifyVector(cubes()) &&
           verifier.VerifyVectorOfTables(cubes()) &&
           VerifyOffset(verifier, VT_SPHERES) &&
           verifier.VerifyVector(spheres()) &&
           verifier.VerifyVectorOfTables(spheres()) &&
           VerifyOffset(verifier, VT_CYLINDERS) &&
           verifier.VerifyVector(cylinders()) &&
           verifier.VerifyVectorOfTables(cylinders()) &&
           VerifyOffset(verifier, VT_LINES) &&
           verifier.VerifyVector(lines()) &&
           verifier.VerifyVectorOfTables(lines()) &&
           VerifyOffset(verifier, VT_TRIANGLES) &&
           verifier.VerifyVector(triangles()) &&
           verifier.VerifyVectorOfTables(triangles()) &&
           VerifyOffset(verifier, VT_TEXTS) &&
           verifier.VerifyVector(texts()) &&
           verifier.VerifyVectorOfTables(texts()) &&
           VerifyOffset(verifier, VT_MODELS) &&
           verifier.VerifyVector(models()) &&
           verifier.VerifyVectorOfTables(models()) &&
           verifier.EndTable();
  }
};

struct SceneEntityBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(const Time *timestamp) {
    fbb_.AddStruct(SceneEntity::VT_TIMESTAMP, timestamp);
  }
  void add_frame_id(flatbuffers::Offset<flatbuffers::String> frame_id) {
    fbb_.AddOffset(SceneEntity::VT_FRAME_ID, frame_id);
  }
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(SceneEntity::VT_ID, id);
  }
  void add_lifetime(const Duration *lifetime) {
    fbb_.AddStruct(SceneEntity::VT_LIFETIME, lifetime);
  }
  void add_frame_locked(bool frame_locked) {
    fbb_.AddElement<uint8_t>(SceneEntity::VT_FRAME_LOCKED, static_cast<uint8_t>(frame_locked), 0);
  }
  void add_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValuePair>>> metadata) {
    fbb_.AddOffset(SceneEntity::VT_METADATA, metadata);
  }
  void add_arrows(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ArrowPrimitive>>> arrows) {
    fbb_.AddOffset(SceneEntity::VT_ARROWS, arrows);
  }
  void add_cubes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CubePrimitive>>> cubes) {
    fbb_.AddOffset(SceneEntity::VT_CUBES, cubes);
  }
  void add_spheres(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SpherePrimitive>>> spheres) {
    fbb_.AddOffset(SceneEntity::VT_SPHERES, spheres);
  }
  void add_cylinders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CylinderPrimitive>>> cylinders) {
    fbb_.AddOffset(SceneEntity::VT_CYLINDERS, cylinders);
  }
  void add_lines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LinePrimitive>>> lines) {
    fbb_.AddOffset(SceneEntity::VT_LINES, lines);
  }
  void add_triangles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TriangleListPrimitive>>> triangles) {
    fbb_.AddOffset(SceneEntity::VT_TRIANGLES, triangles);
  }
  void add_texts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TextPrimitive>>> texts) {
    fbb_.AddOffset(SceneEntity::VT_TEXTS, texts);
  }
  void add_models(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ModelPrimitive>>> models) {
    fbb_.AddOffset(SceneEntity::VT_MODELS, models);
  }
  explicit SceneEntityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SceneEntityBuilder &operator=(const SceneEntityBuilder &);
  flatbuffers::Offset<SceneEntity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SceneEntity>(end);
    return o;
  }
};

inline flatbuffers::Offset<SceneEntity> CreateSceneEntity(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Time *timestamp = 0,
    flatbuffers::Offset<flatbuffers::String> frame_id = 0,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    const Duration *lifetime = 0,
    bool frame_locked = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValuePair>>> metadata = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ArrowPrimitive>>> arrows = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CubePrimitive>>> cubes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SpherePrimitive>>> spheres = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CylinderPrimitive>>> cylinders = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LinePrimitive>>> lines = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TriangleListPrimitive>>> triangles = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TextPrimitive>>> texts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ModelPrimitive>>> models = 0) {
  SceneEntityBuilder builder_(_fbb);
  builder_.add_models(models);
  builder_.add_texts(texts);
  builder_.add_triangles(triangles);
  builder_.add_lines(lines);
  builder_.add_cylinders(cylinders);
  builder_.add_spheres(spheres);
  builder_.add_cubes(cubes);
  builder_.add_arrows(arrows);
  builder_.add_metadata(metadata);
  builder_.add_lifetime(lifetime);
  builder_.add_id(id);
  builder_.add_frame_id(frame_id);
  builder_.add_timestamp(timestamp);
  builder_.add_frame_locked(frame_locked);
  return builder_.Finish();
}

inline flatbuffers::Offset<SceneEntity> CreateSceneEntityDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Time *timestamp = 0,
    const char *frame_id = nullptr,
    const char *id = nullptr,
    const Duration *lifetime = 0,
    bool frame_locked = false,
    const std::vector<flatbuffers::Offset<KeyValuePair>> *metadata = nullptr,
    const std::vector<flatbuffers::Offset<ArrowPrimitive>> *arrows = nullptr,
    const std::vector<flatbuffers::Offset<CubePrimitive>> *cubes = nullptr,
    const std::vector<flatbuffers::Offset<SpherePrimitive>> *spheres = nullptr,
    const std::vector<flatbuffers::Offset<CylinderPrimitive>> *cylinders = nullptr,
    const std::vector<flatbuffers::Offset<LinePrimitive>> *lines = nullptr,
    const std::vector<flatbuffers::Offset<TriangleListPrimitive>> *triangles = nullptr,
    const std::vector<flatbuffers::Offset<TextPrimitive>> *texts = nullptr,
    const std::vector<flatbuffers::Offset<ModelPrimitive>> *models = nullptr) {
  auto frame_id__ = frame_id ? _fbb.CreateString(frame_id) : 0;
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto metadata__ = metadata ? _fbb.CreateVector<flatbuffers::Offset<KeyValuePair>>(*metadata) : 0;
  auto arrows__ = arrows ? _fbb.CreateVector<flatbuffers::Offset<ArrowPrimitive>>(*arrows) : 0;
  auto cubes__ = cubes ? _fbb.CreateVector<flatbuffers::Offset<CubePrimitive>>(*cubes) : 0;
  auto spheres__ = spheres ? _fbb.CreateVector<flatbuffers::Offset<SpherePrimitive>>(*spheres) : 0;
  auto cylinders__ = cylinders ? _fbb.CreateVector<flatbuffers::Offset<CylinderPrimitive>>(*cylinders) : 0;
  auto lines__ = lines ? _fbb.CreateVector<flatbuffers::Offset<LinePrimitive>>(*lines) : 0;
  auto triangles__ = triangles ? _fbb.CreateVector<flatbuffers::Offset<TriangleListPrimitive>>(*triangles) : 0;
  auto texts__ = texts ? _fbb.CreateVector<flatbuffers::Offset<TextPrimitive>>(*texts) : 0;
  auto models__ = models ? _fbb.CreateVector<flatbuffers::Offset<ModelPrimitive>>(*models) : 0;
  return foxglove::CreateSceneEntity(
      _fbb,
      timestamp,
      frame_id__,
      id__,
      lifetime,
      frame_locked,
      metadata__,
      arrows__,
      cubes__,
      spheres__,
      cylinders__,
      lines__,
      triangles__,
      texts__,
      models__);
}

inline const foxglove::SceneEntity *GetSceneEntity(const void *buf) {
  return flatbuffers::GetRoot<foxglove::SceneEntity>(buf);
}

inline const foxglove::SceneEntity *GetSizePrefixedSceneEntity(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<foxglove::SceneEntity>(buf);
}

inline bool VerifySceneEntityBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<foxglove::SceneEntity>(nullptr);
}

inline bool VerifySizePrefixedSceneEntityBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<foxglove::SceneEntity>(nullptr);
}

inline void FinishSceneEntityBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<foxglove::SceneEntity> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSceneEntityBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<foxglove::SceneEntity> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace foxglove

#endif  // FLATBUFFERS_GENERATED_SCENEENTITY_FOXGLOVE_H_
